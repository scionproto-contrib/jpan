// Copyright 2024 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package org.scion.jpan.internal;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;

import java.nio.ByteBuffer;
import org.scion.jpan.ScionUtil;
import org.scion.jpan.internal.util.ByteUtil;
import org.scion.jpan.proto.daemon.Daemon;
import org.scion.jpan.testutil.MockNetwork2;

public abstract class AbstractSegmentsTest {
  protected static final String AS_HOST = MockNetwork2.AS_HOST;

  /** ISD 1 - core AS */
  protected static final long AS_110 = ScionUtil.parseIA("1-ff00:0:110");

  /** ISD 1 - non-core AS */
  protected static final long AS_111 = ScionUtil.parseIA("1-ff00:0:111");

  /** ISD 1 - non-core AS */
  protected static final long AS_1111 = ScionUtil.parseIA("1-ff00:0:1111");

  /** ISD 1 - non-core AS */
  protected static final long AS_1112 = ScionUtil.parseIA("1-ff00:0:1112");

  /** ISD 1 - non-core AS */
  protected static final long AS_112 = ScionUtil.parseIA("1-ff00:0:112");

  /** ISD 1 - non-core AS */
  protected static final long AS_1121 = ScionUtil.parseIA("1-ff00:0:1121");

  /** ISD 1 - core AS */
  protected static final long AS_120 = ScionUtil.parseIA("1-ff00:0:120");

  protected static final long AS_130 = ScionUtil.parseIA("1-ff00:0:130");
  protected static final long AS_131 = ScionUtil.parseIA("1-ff00:0:131");
  protected static final long AS_133 = ScionUtil.parseIA("1-ff00:0:133");

  /** ISD 1 - non-core AS */
  protected static final long AS_121 = ScionUtil.parseIA("1-ff00:0:121");

  /** ISD 2 - core AS */
  protected static final long AS_210 = ScionUtil.parseIA("2-ff00:0:210");

  protected static final long AS_220 = ScionUtil.parseIA("2-ff00:0:220");
  protected static final long AS_221 = ScionUtil.parseIA("2-ff00:0:221");
  protected static final long AS_222 = ScionUtil.parseIA("2-ff00:0:222");

  /** ISD 2 - non-core AS */
  protected static final long AS_211 = ScionUtil.parseIA("2-ff00:0:211");

  protected static void checkMetaHeader(
      ByteBuffer rawBB, int hopCount0, int hopCount1, int hopCount2) {
    int bits = (((hopCount0 << 6) | hopCount1) << 6) | hopCount2;
    assertEquals(bits, rawBB.getInt()); // MetaHeader
  }

  protected static void checkInfo(ByteBuffer rawBB, int segmentId, int flags) {
    assertEquals(flags, rawBB.get()); // Info0 flags
    assertEquals(0, rawBB.get()); // Info0 etc
    if (flags != 0) {
      assertEquals(segmentId, ByteUtil.toUnsigned(rawBB.getShort())); // Info0 SegID
    } else {
      // TODO fix -> XOR SegID! -> assert!
      rawBB.getShort();
    }
    assertNotEquals(0, rawBB.getInt()); // Info0 timestamp
  }

  protected static void checkHopField(ByteBuffer rawBB, int ingress, int egress) {
    assertEquals(63, rawBB.getShort()); // Hop0 flags/expiry
    assertEquals(ingress, rawBB.getShort()); // Hop0 ingress
    assertEquals(egress, rawBB.getShort()); // Hop0 egress
    assertNotEquals(0, rawBB.getShort()); // Hop0 MAC
    assertNotEquals(0, rawBB.getInt()); // Hop0 MAC
  }

  protected static void checkInterface(Daemon.Path path, int i, int id, String isdAs) {
    assertEquals(id, path.getInterfaces(i).getId());
    assertEquals(ScionUtil.parseIA(isdAs), path.getInterfaces(i).getIsdAs());
  }

  /**
   * @param exp byte[] of a raw path returned by a SCION daemon
   * @param act byte[] of raw path generated by Java client from segments from SCION control service
   */
  protected static void checkRaw(byte[] exp, byte[] act) {
    // Path meta header
    for (int i = 0; i < 4; i++) {
      assertEquals(exp[i], act[i], "ofs=" + i);
    }
    int pmh = ByteBuffer.wrap(exp).getInt();
    int s0 = (pmh << 14) >>> (12 + 14);
    int s1 = (pmh << 20) >>> (6 + 20);
    int s2 = (pmh << 26) >>> 26;
    int s = s0 + s1 + s2;

    int ofs = 4;

    // info fields
    assertEquals(exp[ofs], act[ofs++]); // flags
    assertEquals(exp[ofs], act[ofs++]); // RSV
    ofs += 6; // skip segmentID & timestamp
    if (s1 > 0) {
      assertEquals(exp[ofs], act[ofs++]);
      assertEquals(exp[ofs], act[ofs++]);
      ofs += 6; // skip segmentID & timestamp
    }
    if (s2 > 0) {
      assertEquals(exp[ofs], act[ofs++]);
      assertEquals(exp[ofs], act[ofs++]);
      ofs += 6; // skip segmentID & timestamp
    }

    // hop fields
    for (int h = 0; h < s; h++) {
      for (int i = 0; i < 6; i++) {
        assertEquals(exp[ofs], act[ofs++]);
      }
      ofs += 6; // skip MAC
    }

    assertEquals(ofs, exp.length);
    assertEquals(ofs, act.length);
  }
}
